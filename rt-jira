#!/usr/bin/perl
#

use strict;
use Data::Dumper;
use RT::Client::REST;
use JSON;
#use Time::Piece;
use DateTime::Format::Strptime qw(strptime);
use File::Slurp;
use lib qw(/tools/SITE/perl);
use dnutil qw(getUserInfo);
use Devel::Timer;
my $t = Devel::Timer->new();

my $user_map = {
    'hh@dneg.asia'  => 'hh',
};

my $priority_map = {
    5   =>  'Minor',
    3   =>  'Major',
    2   =>  'Critical',
    1   =>  'Blocker',
};

my $filename = $ARGV[0];

$t->mark('begin getUserInfo');
my %useri = getUserInfo();

$t->mark('login to RT');
my $rt = RT::Client::REST->new(server => 'http://rt');
$rt->login(username => undef, password => undef) or die "login fail";

# rad, two date formats out of RT::Client::REST... should just use the real RT API
sub map_datetime {
    my $datetime = shift;
    #my $t = Time::Piece->strptime($datetime, "%a %b %d %T %Y")->datetime;
    my $t = strptime("%a %b %d %T %Y", $datetime)->iso8601;
    return $t;
}
sub map_datetime2 {
    my $datetime = shift;
    #my $t = Time::Piece->strptime($datetime, "%Y-%m-%d %T")->datetime;
    my $t = strptime("%Y-%m-%d %T", $datetime)->iso8601;
    return $t;
}

# rt-importer is a special user to who we will assign all the missing users to
sub map_user {
    my $username = shift;
    return $user_map->{$username} if (exists $user_map->{$username});
    return $username if (exists $useri{$username});
    return 'rt-importer';
}

# undef priority = minor = normal
sub map_priority {
    my $priority = shift;
    return $priority_map->{$priority} if (exists $priority_map->{$priority});
    return 'Minor';
}

my $ticket_map = {
#    Description => first transaction,
    Priority    => 'priority',
    Status      => 'status',
    Creator     => 'reporter',
    Cc          => 'watchers',
    Created     => 'created',
    LastUpdated => 'updated',
    Subject     => 'summary',
    Owner       => 'assignee',
};

my $status_map = {
    'new'       => 'Open',
    'open'      => 'In Progress',
    'resolved'  => 'Resolved',
};


$t->mark('RT search');
my @ids = $rt->search(
    type    => 'ticket',
    query   => 'Queue="tech"',
);

#print Dumper \@ids;

$t->mark('start processing tickets');
my @json_issues;
my $count = 0;
foreach my $id (@ids) {
    print "doing $id\n";
    $t->mark('processing a ticket');
    my @ticket_txns;
    my $ticket = $rt->show(type => 'ticket', id => $id);
    # dump all our transactions into an array
    #my @txns = $rt->get_transaction_ids(parent_id => $id, transaction_type => [ 'Create', 'Comment', 'Correspond' ]);
    my @txns = $rt->get_transaction_ids(parent_id => $id, transaction_type => [ 'Create', 'Correspond' ]);
    #print Dumper \@txns;
    foreach (@txns) {
        push @ticket_txns, $rt->get_transaction(parent_id => $id, id => $_);
    }

    #print Dumper $ticket;

    my $json_ticket = {};
    while (my ($key, $value) = each %$ticket) {
        if (defined $ticket_map->{$key}) {
            if ($value =~ /\d+:\d+:\d+.*20\d+/) {
                $json_ticket->{$ticket_map->{$key}} = map_datetime($value);
            } elsif ($key eq 'Status') {
                $json_ticket->{$ticket_map->{$key}} = $status_map->{$value};
                $json_ticket->{resolution} = 'Fixed' if ($value eq 'resolved');
            } elsif ($key eq 'Owner') {
                $json_ticket->{$ticket_map->{$key}} = map_user($value);
            } elsif ($key eq 'Priority') {
                $json_ticket->{$ticket_map->{$key}} = map_priority($value);
            } else {
                $json_ticket->{$ticket_map->{$key}} = $value;
            }
        }
    }
    $json_ticket->{issueType} = 'Bug';
    $json_ticket->{externalId} = $id;
    $json_ticket->{watchers} = [];
    $json_ticket->{description} = @ticket_txns[0]->{Content};

    push @{$json_ticket->{customFieldValues}}, { 
        fieldName => 'Show Code', 
        fieldType => 'com.atlassian.jira.plugin.system.customfieldtypes:labels',
        value => [ $ticket->{'CF.{Show}'} ] 
    };

    foreach my $txn (@ticket_txns) {
        #next unless ($txn->{Type} eq 'Comment' || $txn->{Type} eq 'Correspond');
        next unless ($txn->{Type} eq 'Correspond');

        my $json_comment = {
            body    => $txn->{Content},
            author  => map_user($txn->{Creator}),
            created => map_datetime2($txn->{Created}),
        };
        push @{$json_ticket->{comments}}, $json_comment;
    }
    push @json_issues, $json_ticket;
    #print Dumper $json_ticket;
    $t->mark('end processing a ticket');
    $count++;
#    last if ($count == 200);
}
$t->mark('end processing tickets');
my $json = {
    projects => [
        {
            name => 'TEST Tech',
            key => 'TT',
            issues => \@json_issues,
        }
    ]
};
#print Dumper \@json_issues;
#print encode_json($json);
write_file($filename, encode_json($json));

$t->mark('END');
$t->report(collapse => 1);
